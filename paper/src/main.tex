\documentclass[12pt]{article}

% sbc template
\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}

% equations
\usepackage{amsmath}
\usepackage{multicol}
\usepackage[version=4]{mhchem}

% code snippets
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

% gro language definition
\definecolor{COLOR_COMMENTS}{RGB}{16, 97, 35}
\definecolor{COLOR_BACKGROUND}{RGB}{230, 230, 230}
\lstdefinelanguage{GROLANG}{
  morekeywords    =   {include,program,rate,ecoli},
  sensitive       =   false,
  morecomment     =   [l]{//},
  morestring      =   [b]",
}
\lstdefinestyle{GROSRC}
{
  language          =   GROLANG,
  basicstyle        =   \footnotesize,
  commentstyle      =   \color{COLOR_COMMENTS},
  backgroundcolor   =   \color{COLOR_BACKGROUND},
  frame             =   single,
  caption           =   Dummy gro file.,
  tabsize           =   4,
  numbers           =   left,
  framesep          =   25pt,
  xleftmargin       =   25pt,
  xrightmargin      =   25pt,
}

% parsed.intermediate style definition
\lstdefinestyle{INTERMEDIATE}{
  basicstyle        =   \footnotesize,
  backgroundcolor   =   \color{COLOR_BACKGROUND},
  caption           =   Compiled dummy.,
  framesep          =   25pt,
  xleftmargin       =   25pt,
  xrightmargin      =   25pt,
}

% output.xml style definiton
\lstdefinestyle{SBML}{
    language        =   XML,
    basicstyle      =   \tiny,
    caption         =   Final SBML document.,
}

% header info
\sloppy
\title{Albi:\\ A Gro compiler to the SBML standard}
\author{Alek Frohlich\inst{1}, Gustavo Biage\inst{1}}
\address{Departamento de Informatica e Estatística – Universidade Federal de Santa Catarina \\
Florianopolis – SC – Brazil
  \email{\{alek.frohlich,gustavo.c.biage\}@grad.ufsc.br}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   => Talk more about antimony where parsed.itermidiate is referenced
%   => more explanation about reaction parameters if fig2/3
%   => footnote under sys of ODE
%   => fix gro code snipets
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% end of preamble
\begin{document}
\maketitle
\begin{abstract}


    The growth of research areas such as synthetic biology and systems biology leads to an increased tendency to develop larger mathematical models for describing complex biological behavior. In order to enable natural flow of development of those models, scientists must have access to tools which increase the level of abstraction and enable the reuse of biological components. The present work tackles those two problems by integrating the existing programming language gro with the SBML standard for model interchangeability and ease of model design.


\end{abstract}
\section{Introduction}


    Even though a Systems Biology Markup Language API (LibSBML) has already been developed \cite{Bornstein2008}, it only ought to be useful in cases where a new model is to be developed. In cases where there is a preexisting model, the availability of an SBML library does not help much since the previous model would have to be entirely rewritten to fit the API. Instead, the present work proposes an integration scheme that makes use of a language parser to generate SBML documents from previously built gro models. Gro is a language for programming, modeling, specifying and simulating the behavior of cells in growing microcolonies of microorganisms \cite{Jang2012}. The parser has been built upon it considering gro has many interesting syntactical constructs such as rate statements\footnote{Here, and all throughout this paper we shall refer to expressions guarded by gro's rate function as rate statements.}, program definitions and bacterial instantiation which can be expressed, respectively, as reactions, local name spaces and compartments in SBML documents.
    
    In regards to language support, gro is still tightly coupled with it's original simulator. Although the simulator has recently undergone big improvements in the sense that simulations behave more realistically \cite{Gutirrez2017}, it doesn't change the fact that using it is the only available way to validate gro models. This hinders the reproducibility of experiments built with the language. SBML models, on the other hand, are supported by more than 100 software systems \cite{Hucka2007}, making them more likely to be verified and reused.
    
    If gro code were translated into SBML, the resulting document could then be further preserved as an entry in BioModels. BioModels is a database of curated SBML and CellML models intended to provide researchers with models related to a particular disease, biological process or molecular complex \cite{LeNovere2006}. Having a model curated is an even stronger guarantee of trustworthiness since the process is done manually for each model: Newly submitted models go through a series of syntactical analysis to confirm that they are valid and well formatted; The model is then numerically verified against the results claimed by the authoring paper; Finally, the validated model gets manually annotated and cross-linked to facilitate later search for it \cite{LeNovere2006}.
    
    The rest of the paper is structured as follows: In Sect. 2, we introduce the language parser and explain the process of converting gro files to SBML models from start to finish; In Sect. 3, we demonstrate a possible use case for the proposed SBML integration scheme through simulating an SBML model generated from gro source code; In Sect. 4, we summarize what has been done and compare it with goals laid out at the start; In Sect. 5 we conclude by presenting possible extensions of the current work.
    

\section{Architecture}

    
    The compilation process is divided in three steps: First, the code is validated, that is, it's checked against syntax errors such as missing semicolon in rate statements and semantic error such as using undeclared variables; Then the code gets compiled to Antimony, a modular model definition language \cite{Smith2009}; This format guides Tellurium in building the final SBML document. As we'll see in the following subsections, Tellurium makes use of the aforementioned libSBML API for code generation purposes.


\subsection{The parser}
    
    Currently, the parser only recognizes a subset of gro's syntax. Valid programs are constituted by global variable declarations, program definitions and E. coli instantiations. Parameters, messages and guarded statements are also recognized as valid syntax, however no semantic value is assigned to them given that control statements and user interaction do not make sense in the context of an SBML model. Below is an example of gro code containing the syntactical constructs just described.
    
    % The only part developed was the basic functionality needed for a reaction description, the goal for the study case is to also explore how higher level of descriptions can be well translated in a more precise format, this includes: if and else; for each; and or other programming instructions that that differentiates from how biological reactions work. Take for instance how reactions can not be turned off and "if and else" instructions needs remodelling to a chemical point of view, however, a lot of bi-stability models, including switcher, present good expectations.

    \input{example_gro.tex}
    
    Compiling this file gives us \textit{parsed.intermediate}, the input file for Tellurium. As we can see, the compiler properly handled arithmetic expressions and parameter passing. The compiler also renamed symbols declared inside program definitions to avoid name space clashes between multiple programs instantiated in the same compartment. If this renaming hadn't been done, there wouldn't be a way to differentiate the symbol E, whose name space is limited to reactions inside of prog, from the symbol E which was declared inside of dupl.
    
    \input{example_compiled.tex}
    
\subsection{The Tellurium framework}

    Tellurium is a Python-based modeling environment for systems and synthetic biology \cite{Choi2018}. It aggregates multiple preexisting libraries such as libSBML, libAntimony and libSBOL to provide the modelling community access to an integrated modelling environment. Tellurium is organized in three functional pillars: Standards support, modelling support and utilities. We made extensive use of the libAntimony integration provided by standard support to build our SBML documents.


\section{Case study: The Repressilator}


    The goal of this experiment was to illustrate the proposed SBML integration scheme and so the experiment was conducted as follows: We first simulated the gro model for a well-known biological device, the Repressilator, in gro's built-in simulator; We Then compiled the source code down to SBML following the steps shown in Sect. 2; Finally we simulated the compiled gro code, an SBML document, in COPASI. Both simulations were done with the same initial conditions. We also compared the results from both simulators.


\subsection{Mathematical Model}

    \begin{figure}[h]
        \centering
        \includegraphics[scale = 0.7]{repressilator_model.png}
        \caption{Repressilator's genetic regulatory network.}
        \label{fig:repressilator_model}
    \end{figure}
    
    The Repressilator is a genetic regulatory network constituted by stitching together promoter-repressor pairs. It was first conceptualized by \cite{Elowitz2000}, who used the genes LacI and letR from E. coli and cI from phage lambda to build a three-repressor scheme. As illustrated in Figure~\ref{fig:repressilator_model}, the Repressilator works based on the fact that each gene expresses a protein which represses the next gene in the loop, meaning that a constituent gene in high concentration represses itself indirectly, leading to oscillatory behavior. In the original experiment, there was another biological component involved: the reporter, a green fluorescent protein (GFP) producing gene. It was used to visualize the network's oscillation.
    
    \begin{equation}
    \begin{aligned}[c]
        \frac{dm_{1}(t)}{dt} & = \alpha_{0} + \frac{\alpha}{1 + p_{3}(t)^{n}} - m_{1}(t) & \\
        \frac{dm_{2}(t)}{dt} & = \alpha_{0} + \frac{\alpha}{1 + p_{1}(t)^{n}} - m_{2}(t) & \\
        \frac{dm_{3}(t)}{dt} & = \alpha_{0} + \frac{\alpha}{1 + p_{2}(t)^{n}} - m_{3}(t) &
    \end{aligned}
    \begin{aligned}[c]
        \frac{dp_{1}(t)}{dt} & = \beta \cdot m_{1}(t) - \beta \cdot p_{1}(t) \\
        \frac{dp_{2}(t)}{dt} & = \beta \cdot m_{2}(t) - \beta \cdot p_{2}(t) \\
        \frac{dp_{3}(t)}{dt} & = \beta \cdot m_{3}(t) - \beta \cdot p_{3}(t)
    \end{aligned}
    \end{equation}

    As shown in \cite{Elowitz2000}, the high-level model from Figure~\ref{fig:repressilator_model} could also be presented as the above system of Ordinary Differential Equations (ODE)\footnote{AA}. With that system of equations, we then built the corresponding gro model. The process was simple as we just separated the reactions from the equations, meaning, for example, that $\alpha_{0}$ from the left equations became the open reaction:
    
    \begin{equation}
    \ce{ ->[\alpha_{0}] m_{1} + m_{2} + m_{3}}
    \end{equation}
    
    On repeating this process for each ODE, we ended up with a total of 7 reactions, from which the new ones are listed below:
    
    % Substituir reações pela imagem da network, valores indentificaods segundo o livro.
    \begin{figure}[h]
        \centering
        \includegraphics[scale = 0.6] {Topicos_reaction_network.png}
        \caption{Caption}
        \label{fig:my_label}
    \end{figure}
    
    \begin{equation}
    \begin{aligned}[c]
        \ce{ <=>[\alpha/(1 + p_{3}^n)][m_{1}] m_{1}} & & \\
        \ce{ <=>[\alpha/(1 + p_{1}^n)][m_{2}] m_{2}} & & \\
        \ce{ <=>[\alpha/(1 + p_{2}^n)][m_{3}] m_{3}} & &
    \end{aligned}
    \begin{aligned}[c]
        \ce{ <=>[\beta*m_{1}][\beta*p_{1}] p_{1}} \\
        \ce{ <=>[\beta*m_{2}][\beta*p_{2}] p_{2}} \\
        \ce{ <=>[\beta*m_{3}][\beta*p_{3}] p_{3}}
    \end{aligned}
    \end{equation}
    
    From which the source code for the Repressilator was implemented. One thing to note about the gro simulator, however, is that it does not provide a way to express reversible reactions. That's the reason for the 13, and not 7, rate statements in the following gro code.
    
    \input{repressilator_gro.tex}

\subsection{Gro}
    
    Gro simulates multiple different aspects of the bacterial colony, including growth, division and contact forces between cells \cite{Jang2012}. Although that makes for a realistic multicellular simulator, it doesn't carry weight in single cell simulation such as the ones we did for the Repressilator shown in the last section. In it's case, the uniquely relevant aspect of it's simulation was how gro evaluated rate statements. As is indicated by \cite{Hoops2006}, at each simulation step, each guard is evaluated. If it evaluates to true, then the corresponding block is executed, meaning, in our case, that a reaction occurred. To model stochastic events, gro provides the \textit{rate} (\textit{r}) function that evaluates to true under the probability of r*dt, where the dt is the step size of the simulation. Simulation parameters in the likes of dt can be set by using the \textit{set} (\textit{key}, \textit{value}) function. Gro makes further use of the \textit{rate} function to approximate the Master Equation with Euler integration. 
    
    \begin{figure}[ht]
    \centering
    \minipage{0.33\textwidth}
      \includegraphics[width=\linewidth]{img1.png}
    \endminipage\hfill
    \minipage{0.33\textwidth}
      \includegraphics[width=\linewidth]{img2.png}
    \endminipage\hfill
    \minipage{0.33\textwidth}%
      \includegraphics[width=\linewidth]{img3.png}
    \endminipage
    \caption{Multiple simulations of the Repressilator gro model. From left to right: p1, p2, p3. Black lines are used to indicate an average simulation, whilst the various grey lines are used to indicate the concentration of the respective protein at each individual simulation.}
    \label{fig:tons_of_simulations}
    \end{figure}

   In Figure~\ref{fig:tons_of_simulations}, we see the results of simulating the Repressilator model within gro itself. Simulation parameters taken from \cite{ingalls2013mathematical}: $\alpha_{0} = 0.03$ (molecules per $cell*min^{-1}$), $\alpha = 298.2$ (molecules per $cell*min^{-1}$), $\beta = 0.2$ ($min^{-1}$), $n = 2$ and $\delta t = 0.0001$. The average simulation containing all of $p_{1}, p_{2}, p_{3}, m_{1}, m_{2}, m_{3}$ and illustrated by Figure~\ref{fig:repressilator_average} shows that the original period and amplitude varied during the course of time, probably due to stochastic fluctuations. From a naive perspective, nonetheless, the model maintained it's oscillatory behavior. Delving deeper, we are able to conclude by analysis of the bifurcation graph from Figure~\ref{fig:biffurcation} for $\alpha$ and $\beta$ that, that the initial values picked for the simulations could be tuned to increase the robustness of the outcome under stochastic simulations.

    \begin{figure}[ht]
    \centering
    \minipage{0.5\textwidth}
      \includegraphics[width=\linewidth]{all_med_thick.png}
      \caption{Average of the protein's concentrations over multiple simulations. $p_{1}$, $p_{2}$ and $p_{3}$ is represented, respectively, by the color red, green and blue}
      \label{fig:repressilator_average}
    \endminipage\hfill
    \minipage{0.5\textwidth}
      \includegraphics[width=\linewidth]{biffurcation_a_b_2.png}
      \caption{
      Phase plane from the $\alpha$ and $\beta$ values parameter values, for the parameters used above, $\alpha$ stands around $10^{2}$ and $\beta$ in $10^{-1}$ power of magnitude.}
      \label{fig:biffurcation}
    \endminipage\hfill
    \end{figure}

\subsection{COPASI}
    
    COPASI is a software package for simulating chemical reactions. We chose to simulate the resulting SBML document on it because of the variety of simulation methods that it supports. Ranging all the way from deterministic methods such as LSODA \cite{Petzold1983} to stochastic ones like Gillespie’s algorithm \cite{Gillespie1976}. Unfortunately, as gro does not implement any well-known method\footnote{Gro concurrently simulate growth, geometry, and signal dynamics. Meaning that any other resource-intensive simulation methods would be impractical due to performance reasons.} we shall compare COPASI's output only with that of \cite{Goeldner2019}, whom implement the same starting conditions as \cite{ingalls2013mathematical}. The simulation is presented in Figure~\ref{fig:biffurcation}
    
    \begin{figure}[ht]
    \centering
    \minipage{0.5\textwidth}
      \includegraphics[width=\linewidth]{octave_plot_thick.png}
      \caption{Plot generated by octave from the derivatives presented in the mathematical model, using $\delta{t} = 0.01$ and and $10000$ intervals}
      \label{fig:repressilator_octave}
    \endminipage\hfill
    \minipage{0.5\textwidth}
      \includegraphics[width=\linewidth]{SBML_copasi_LSODA.png}
      \caption{Copasi LSODA deterministic simulation using the SBML file generate using Albi from the repressilator model in Gro, was simulated up to $100$ seconds with $10000$ interevals.}
      \label{fig:repressilator_copasi}
    \endminipage\hfill
    \end{figure}
    
    As per simple analysis of both graphs we can conclude that the behavior of both models was indeed similar. In order to prove that both models are identical, however, we need to compare the underlying systems of equations. Since the Octave model from Figure~\ref{fig:repressilator_octave} was implemented based on (1), the only remaining thing there is to show is the equations used by COPASI. To accomplish this, we explore the fact that COPASI infers the math equations back from the SBML model. Hence, by looking at the equations bellow, we can conclude that our integration scheme achieved it's purposed goal.
    
    \begin{multline*}
        \frac{d([ECOLI0\_prog\_m1]*V_{ECOLI0})}{dt} = +V_{ECOLI0}*(\frac{alfa + [ECOLI\_prog_p3]^n}{V\_{ECOLI0}}) \\ +V_{ECOLI0}*(\frac{alfa0}{V_{ECOLI0}}) -V_{ECOLI0}*(\frac{[ECOLI0\_prog\_m1]}{V_{ECOLI0}})
    \end{multline*}
    \begin{multline*}
        \frac{d([ECOLI0\_prog\_m2]*V_{ECOLI0})}{dt} = +V_{ECOLI0}*(\frac{alfa + [ECOLI\_prog_p1]^n}{V\_{ECOLI0}}) \\ +V_{ECOLI0}*(\frac{alfa0}{V_{ECOLI0}}) -V_{ECOLI0}*(\frac{[ECOLI0\_prog\_m2]}{V_{ECOLI0}})
    \end{multline*}
    \begin{multline*}
        \frac{d([ECOLI0_prog_m3]*V_{ECOLI0})}{dt} = +V_{ECOLI0}*(\frac{alfa + [ECOLI_prog_p2]^n}{V_{ECOLI0}}) \\ +V_{ECOLI0}*(\frac{alfa0}{V_{ECOLI0}}) -V_{ECOLI0}*(\frac{[ECOLI0_prog_m1]}{V_{ECOLI0}})
    \end{multline*}
    \begin{multline*}
        \frac{d([ECOLI0_prog_p1]*V_{ECOLI0})}{dt} = -V_{ECOLI0}*(\frac{beta*[ECOLI_prog_p1]^n}{V_{ECOLI0}}) \\ +V_{ECOLI0}*(\frac{beta*[ECOLI_prog_m1]^n}{V_{ECOLI0}})
    \end{multline*}
    \begin{multline*}
        \frac{d([ECOLI0_prog_p2]*V_{ECOLI0})}{dt} = -V_{ECOLI0}*(\frac{beta*[ECOLI_prog_p2]^n}{V_{ECOLI0}}) \\ +V_{ECOLI0}*(\frac{beta*[ECOLI_prog_m2]^n}{V_{ECOLI0}})
    \end{multline*}
    \begin{multline*}
        \frac{d([ECOLI0_prog_p3]*V_{ECOLI0})}{dt} = -V_{ECOLI0}*(\frac{beta*[ECOLI_prog_p3]^n}{V_{ECOLI0}}) \\ +V_{ECOLI0}*(\frac{beta*[ECOLI_prog_m3]^n}{V_{ECOLI0}})
    \end{multline*}
    

\section{Conclusion \& Future works}
    
    
    We have presented an SBML integration scheme for the gro language with the intent of facilitating the development of new SBML models through the now possible use of the gro programming language as a modelling tool. Also, the proposed scheme aimed to recover previously built gro models, as done in section 3. with the Repressilator. For those goals to be effectively reached, the language parser should be able to handle all possible gro programs. That's not currently the case as signalling and structures have not yet been implemented and could serve as practical extension of the current work.


% references
\bibliographystyle{sbc}
\bibliography{sbc-template}
\end{document}
